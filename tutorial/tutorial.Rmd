---
title: "RNODE"
author: "Daniel YM Nakamura, Ward Wheeler, Taran Grant"
date: "5 November 2025"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Preamble

Tutorial to demonstrate the main functions available in the R package \code{RNODE}. 

```{r warning=F, message=F}
# Set the working directory 
knitr::opts_knit$set(root.dir = "/Users/labanfibios/Desktop/Doutorado/Project/B5_RNODE/RNODE/tutorial/")

# Load the package
library(ggplot2)
library(RNODE)
```

# 1. Example 1: Comparison of support values between trees

## 1.1 Identify shared and unique clades

Comparisons between phylogenetic trees are usually performed using topological distance metrics (e.g. Robinson-Foulds and SPR distances) but comparisons of support values between corresponding nodes are usually neglected. We propose the function **sharedNodes** to create a dataframe with node labels, descendants, and support values of shared clades between two phylogenetic trees, which facilitates descriptive and statistical comparisons of support values between corresponding nodes. Two examples are provided below.

First, we can demonstrate this function using two simulated trees with the same composition of terminals but different topologies. Notice that *composition = T* will show the composition of each clade in the output dataframe.

```{r}
# Simulate two trees
set.seed(44)
a = pbtree(n=7) # initial tree a
node_labels = sample(1:100, a$Nnode, replace = TRUE) # generate random node labels as integers to tree a
a$node.label = node_labels # add the node labels to tree a
set.seed(88)
b = pbtree(n=7) # initial tree b
node_labels = sample(1:100, b$Nnode, replace = TRUE) # Generate random node labels as integers to tree a
b$node.label = node_labels # Set the node labels to tree b

# Visualize trees
#layout(c(1,2))
#plotTree(ladderize(a, right = T),node.numbers=T, color="blue")
#nodelabels(a$node.label,
#           adj=c(1.9, 1.7), # horizontal and vertical position
#           frame="none")
#plotTree(ladderize(b, right = T),node.numbers=T, color="red")
#nodelabels(b$node.label,
#           adj=c(2, 1.7), # horizontal and vertical position
#           frame="none")

# Run 
df = sharedNodes(tree1=a, tree2=b, composition=T, 
                 plotTrees = T,
                 output.tree1="example1.1_simulated1.pdf",
                 output.tree2="example1.1_simulated2.pdf", 
                 tree.width = 3, # adjust tree width
                 tree.height = 4, # adjust tree height
                 tree.fsize = 1, # adjust font size
                 tree.adj=c(1.2,3), # adjust support position
                 tree.cex=.5, # adjust support size
                 node.numbers=F) # show node index
```

In contrast to **sharedNodes**, the list of descendants and support values of unique clades from each tree can be assessed using **uniqueNodes**.

```{r}
uniqueNodes(a, b, composition=T, dataframe=T,
            plotTrees=T, output.tree = "example1.1_unique.pdf",
            node.numbers=F, # show node index
            tree.fsize=2, # adjust text size
            tree.cex=3.5, # adjust circle size
            sup.adj1=c(-.2,4), # adjust support from tree a
            sup.adj2=c(1.3,4) # adjust support from tree b
            )
```

## 1.2 Support comparisons

We can use **sharedNodes** to compare two empirical trees in .nwk format estimated in TNT. Polytomies and input trees with different taxon samples are accepted but names of corresponding leaves should be equal in the input trees.

For instance, using the data set from Whitcher et al. (2025), we can plot the relationship of bootstrap values between molecular (MOL) and total evidence (TE) trees analyzed in TNT.

```{r}
# Load trees
MOL = read.tree("../testdata/051b_MOL_BS_TNT.nwk")
TE = read.tree("../testdata/051d_TE_BS_TNT.nwk")

# Run sharedNodes
df = sharedNodes(tree1=MOL, tree2=TE, spearman = T)

# Plot the relationship of support between trees
ggplot(df, aes(as.numeric(Support_Tree_1), as.numeric(Support_Tree_2))) +
  geom_point(size = 5, show.legend = F, alpha=.5) +
  theme_minimal() + 
  geom_smooth(method = "lm", se = T, color = "red", linewidth = .5) +
  labs(x="\n Bootstrap in the MOL tree",
       y="Bootstrap in the TE tree \n")
```

As expected, there is a significant correlation between bootstrap values of MOL and TE trees (Spearman: rho = 0.89; P < 0.001). 

## 1.3 Logistic regressions

If the user wants to test if support values of one tree predict the occurrence of clades in another tree, the function **retrodictNodes** creates a dataframe containing support values of tree 1 and the occurrence of the clade in tree 2, which can be used for logistic regressions.

```{r}
# Load trees
MOL = read.tree("../testdata/001_MOL_IQTREE.contree")
TE = read.tree("../testdata/001_TE_ASC_IQTREE.contree")

# Run retrodictNodes
df = retrodictNodes(MOL, TE)
df$occurrence_tree2 = as.factor(df$occurrence_tree2)

# Fit the logistic regression
model <- glm(occurrence_tree2 ~ support_tree1, data = df, family = binomial)
summary(model)

# Convert log-odds to odd ratios
exp(coef(model))
```

Using the data set from Janssens et al. (2018), the logistic regression revealed an intercept of 0.009 (i.e. when bootstrap is 0 in the first tree, the odds of presence of the clade in the second tree is 0.009; P < 0.01). Furthermore, for every one-unit increase in bootstrap in the first tree, the odds of presence of the clade in the second tree increase by 1.075 (7.5%). 

## 1.4 Branch length comparisons

In addition to descendants and support values, branch lengths can be compared. Here we used two simple simulated examples.

```{r}
# Read trees
mol = read.tree("../testdata/003_MOL_IQTREE.contree")
te = read.tree("../testdata/003_TE_ASC_IQTREE.contree")

# plot side-by-side
par(mfrow = c(1,2), mar = c(4,4,2,1))  # 1 row, 2 cols
plot(mol, main = "Tree 1", cex = 1, edge.width = 2)
edgelabels(round(mol$edge.length, 3), cex = 0.5)  # show branch length
nodelabels(node = 1:mol$Nnode + length(mol$tip.label), 
            adj = c(1.2, -1), frame = "none", cex = 0.8, col = "red") # show node indices
plot(te, main = "Tree 2", cex = 1, edge.width = 2)
edgelabels(round(te$edge.length, 3), cex = 0.5) # show branch length
nodelabels(node = 1:te$Nnode + length(te$tip.label),
            adj = c(1.2, -1), frame = "none", cex = 0.8, col = "red") # show node indices

# Compare branch lengths
df = RNODE::compareBranchLength(mol, te, composition=F)

# Correlation between branch lengths
summary(lm(data=df, formula=EdgeLength_tree1 ~ EdgeLength_tree2))

# Plot 
ggplot(df, aes(as.numeric(EdgeLength_tree1), as.numeric(EdgeLength_tree2))) +
  geom_point(size = 5, show.legend = F, alpha=.5) +
  theme_minimal() + 
  geom_smooth(method = "lm", se = T, color = "red", linewidth = .5) +
  labs(x="\n Branch lengths in the MOL tree",
       y="Branch lengths in the TE tree \n")
```

## 1.5 Topological distances

In addition to comparisons between shared clades, support values and branch lengths, a popular method to compare phylogenies is based on topological metrics. Popular metrics like Robinson-Foulds and Cluster Information distances can be summarized using **summaryTopologicalDist**. Moreover, a common topological metric is the number of SPR moves to edit one tree into another tree. However, implementations are lacking in R to normalize SPR distances using the refined upper bound from Ding et al. (2011) (**normalizedSPR**) and computing SPR distances for polytomous trees (**multiSPR**). 

```{r}
# Read trees
mol = read.tree("../testdata/003_MOL_IQTREE.contree")
te = read.tree("../testdata/003_TE_ASC_IQTREE.contree")

# RF and CID
summaryTopologicalDist(mol, te)

# Normalized SPR
normalizedSPR(mol, te)
```

# 2. Comparison of DNA sequences

# 3. Manipulation of matrices

## 3.1 Handling morphological matrices

The function *filterMissing* deletes taxa and/or characters containing only missing data. In the following example, the output file will be saved as *test_filterMissing_FILTERED.nexus*:

```{r}
filterMissing(input="../testdata/test_filterMissing.nexus", 
              output_path="../testdata/test_filterMissing",
              missing="both")
```

The function *filterInvariants* deletes invariant characters, which is useful to accelerate the graph searches. In Maximum Likelihood and Bayesian analyses using the MKv model with ascertainment bias correction (ASC), invariants must be deleted. Here, we follow the definition of invariant from IQ-Tree, characterized by: (1) constant sites containing only a single character state in all sequences, (2) partially constant sites (N and/or -), and (3) ambiguously constant sites (e.g. C, Y and -). In the following example, 122 invariants are detected.

```{r}
filterInvariants(input="../testdata/015_MORPH_data.nexus",
                 output_index="../testdata/015_MORPH_data")
```

The function *splitOrdFromUnord* splits a Nexus morphological matrix into partitions of ordered and unordered characters based on a list of ordered characters.

```{r}
# Data input of list of ordered characters
list_ordered=c(1, 6, 7, 8, 10, 12, 13, 14, 17, 19, 23, 26, 31, 35, 41, 44, 45, 48, 51, 54, 55, 68, 71, 72, 92, 94, 96, 102, 105, 108, 109, 128, 129, 130, 131, 132, 135, 142, 144, 152, 153, 193)

splitOrdFromUnord(input="../testdata/048_MORPH_data.nex", output_index = "../testdata/048_MORPH", list_ordered=list_ordered)
```

The function *splitNoStates* splits characters from a Nexus morphological matrix according to their number of character-states. This procedure has been recommended to run phylogenetic analyses with the MK and MKv models (the 'K' refers to the number of states). Khakurel et al. (2024) demonstrated that MK models with high K values can understimate the branch lengths, whereas MK models with small K values can overstimate them. As such, some recent studies have partitioned morphological characters according to their number of states (e.g. Černý & Simonoff 2023).

```{r}
# Synthetic example
mat <- matrix(c(
  "0","1","01","-","?","[01]","1","0",   # row1
  "0","1","02","-","?","[02]","1","0",   # row2
  "1","0","2" ,"-" ,"?" ,"[012]","1","0", # row3
  "-" ,"-","-" ,"-" ,"?" ,"-","1","0"    # row4
), nrow = 4, byrow = TRUE)

colnames(mat) <- paste0("C", 1:ncol(mat))
mat

# Case A: ignore ambiguities, ignore "-" (default)
outA <- splitNoStates(mat, ambiguity_addState = FALSE, inapplicable_addState = FALSE, write=F)
outA

# Case B: ignore ambiguities, count "-" as a state
outB <- splitNoStates(mat, ambiguity_addState = FALSE, inapplicable_addState = TRUE, write=F)
outB

# Case C: treat ambiguous tokens as separate states (ambiguity_addState = TRUE)
outC <- splitNoStates(mat, ambiguity_addState = TRUE, inapplicable_addState = T, write=F)
outC
```

```{r}
# Empirical example
a = splitNoStates(input = "../testdata/015_MORPH_data.nexus", input_format = "nexus", output_index = "../testdata/015_MORPH_data", ambiguity_addState = T, inapplicable_addState = T, log=T, write=T)
```

## 3.2 Find equal-length partitions

*findEqualLength*

# 4. Manipulation of trees

## 4.1 Mapping support

Given a tree A without support values (e.g. strict consensus of optimal trees) and a tree B with support values (e.g. majority consensus from bootstrap pseudo-replicates), *mapSupport()* returns the tree A with support values from shared clades with tree B. For instance, the strict consensus of optimal trees and the majority consensus tree from bootstrap trees share 223 clades, presenting 6 unique clades in the strict consensus and 1 unique clade in the bootstrap tree.  

```{r}
# Read trees
opt = read.tree("../testdata/051a_strictConsensus_MOL_TNT_results.nwk")
BS = read.tree("../testdata/051b_MOL_BS_TNT.nwk")

# Compute topological distances
summaryTopologicalDist(opt, BS)

# Map the BS values from the majority consensus tree to the optimal tree
opt_with_bs = mapSupport(opt, BS)
opt_with_bs[1]

# Plot the optimal tree with BS and the majority consensus tree with BS
uniqueNodes(opt_with_bs[[1]], BS, 
            plotTrees=T, output.tree = "example5.pdf",
            node.numbers=F, 
            tree.fsize=.25, # adjust text size
            tree.cex=1.5, # adjust circle size
            sup.adj1=c(-.2,4), # adjust support from tree a
            sup.adj2=c(1.3,4), # adjust support from tree b
            sup.cex=.25)
```

## 4.2 Mapping branch lengths

Another option is mapping branch lengths using *mapBranchLength*. We can map branch lengths to the strict consensus either using the minimum values from a pool of MPTs or randomly selecting one of the MPTs.

```{r}
set.seed(1)
# Simulate tree1
tree1 <- rtree(n=8)
# Simulate tree2 (similar to tree1, with one rearrangement and different branch lengths)
tree2 = tree1
tree2 <- rNNI(tree2, n = 1)  # perform one NNI (one rearrangement)
edges_to_change <- sample(1:length(tree2$edge.length), 6)
tree2$edge.length[edges_to_change] <- tree2$edge.length[edges_to_change] * runif(6, 0.5, 1.5)
trees2 = list(tree1, tree2)

# Compute the strict consensus tree
strict <- consensus(list(tree1, tree2), p = 1.0)

# Map using minimum branch length per shared edge
mapped_min <- mapBranchLength(strict, trees2, method = "minimum")

# Map using random tree
mapped_rand <- mapBranchLength(tree1, trees2, method = "random")

# Set up 1x4 plotting
png("../tutorial/example4.2_simulated.png", width = 2400, height = 800, res = 150)  # high-resolution
par(mfrow = c(1, 4), mar = c(4, 4, 2, 2))
# Plot Tree 1
plot(tree1, main = "Tree 1")
ape::edgelabels(round(tree1$edge.length, 2), cex = 0.5)
#ape::nodelabels(1:tree1$Nnode + length(tree1$tip.label), frame = "circle", cex = 0.5)
# Plot Tree 2
plot(tree2, main = "Tree 2")
ape::edgelabels(round(tree2$edge.length, 2), cex = 0.5)
#ape::nodelabels(1:tree2$Nnode + length(tree2$tip.label), frame = "circle", cex = 0.5)
# Plot Strict Consensus
plot(strict, main = "Strict Consensus")
ape::nodelabels(1:strict$Nnode + length(strict$tip.label), frame = "circle", cex = 0.5)
# Plot Mapped Minimum
plot(mapped_min, main = "Mapped Minimum")
ape::edgelabels(round(mapped_min$edge.length, 2), cex = 0.5)
#ape::nodelabels(1:mapped_min$Nnode + length(mapped_min$tip.label), frame = "circle", cex = 0.5)
dev.off()  # close the PNG device
```

Using empirical data from Nakamura et al. 2025:

```{r}
strict = read.tree("../testdata/cymb_IP_GB.1.nwk")
mpts = read.tree("../testdata/cymb_IP_trees.nwk")

# Map using minimum branch length per shared edge
mapped_min <- mapBranchLength(strict, mpts, method = "minimum")

# Plot strict + mapped side by side
png("../tutorial/example4.2.png", width = 2400, height = 4000, res = 150)
par(mfrow = c(1, 2),            # 1 row, 2 columns
    mar = c(4, 4, 2, 2),        # margins
    oma = c(1, 1, 1, 1))        # outer margins
# Panel 1 — strict consensus
plot(ladderize(strict),
     main = "Strict Consensus Tree",
     cex = 0.8)
# Panel 2 — mapped branch lengths
plot(ladderize(mapped_min),
     main = "Mapped Branch Lengths (Minimum)",
     cex = 0.8)
dev.off()
```


# 6. References


