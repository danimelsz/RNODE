---
title: "RNODE"
author: "Daniel YM Nakamura, Ward Wheeler, Taran Grant"
date: "5 November 2025"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1. Preamble

Tutorial to demonstrate the main functions available in the R package \code{RNODE}. This tutorial is organized in two sections related to preprocessing and post-processing of phylogenetic trees.

```{r warning=F, message=F}
# Set the working directory 
knitr::opts_knit$set(root.dir = "/Users/labanfibios/Desktop/Doutorado/Project/B5_RNODE/RNODE/tutorial/")

# Load the package
library(ggplot2)
library(RNODE)
```

# 2. Example 1: Comparison of support values between trees

## 2.1 Identify shared and unique clades

Comparisons between phylogenetic trees are usually performed using topological distance metrics (e.g. Robinson-Foulds and SPR distances) but comparisons of support values between corresponding nodes are usually neglected. We propose the function **sharedNodes** to create a dataframe with node labels, descendants, and support values of shared clades between two phylogenetic trees, which facilitates descriptive and statistical comparisons of support values between corresponding nodes. Two examples are provided below.

First, we can demonstrate this function using two simulated trees with the same composition of terminals but different topologies. Notice that *composition = T* will show the composition of each clade in the output dataframe.

```{r}
# Simulate two trees
set.seed(44)
a = pbtree(n=7) # initial tree a
node_labels = sample(1:100, a$Nnode, replace = TRUE) # generate random node labels as integers to tree a
a$node.label = node_labels # add the node labels to tree a
set.seed(88)
b = pbtree(n=7) # initial tree b
node_labels = sample(1:100, b$Nnode, replace = TRUE) # Generate random node labels as integers to tree a
b$node.label = node_labels # Set the node labels to tree b

# Visualize trees
#layout(c(1,2))
#plotTree(ladderize(a, right = T),node.numbers=T, color="blue")
#nodelabels(a$node.label,
#           adj=c(1.9, 1.7), # horizontal and vertical position
#           frame="none")
#plotTree(ladderize(b, right = T),node.numbers=T, color="red")
#nodelabels(b$node.label,
#           adj=c(2, 1.7), # horizontal and vertical position
#           frame="none")

# Run 
df = sharedNodes(tree1=a, tree2=b, composition=T, 
                 plotTrees = T,
                 output.tree1="example1.1_simulated1.pdf",
                 output.tree2="example1.1_simulated2.pdf", 
                 tree.width = 3, # adjust tree width
                 tree.height = 4, # adjust tree height
                 tree.fsize = 1, # adjust font size
                 tree.adj=c(1.2,3), # adjust support position
                 tree.cex=.5, # adjust support size
                 node.numbers=F) # show node index
```

In contrast to **sharedNodes**, the list of descendants and support values of unique clades from each tree can be assessed using **uniqueNodes**.

```{r}
uniqueNodes(a, b, composition=T, dataframe=T,
            plotTrees=T, output.tree = "example1.1_unique.pdf",
            node.numbers=F, # show node index
            tree.fsize=2, # adjust text size
            tree.cex=3.5, # adjust circle size
            sup.adj1=c(-.2,4), # adjust support from tree a
            sup.adj2=c(1.3,4) # adjust support from tree b
            )
```

## 2.2 Support comparisons

We can use **sharedNodes** to compare two empirical trees in .nwk format estimated in TNT. Polytomies and input trees with different taxon samples are accepted but names of corresponding leaves should be equal in the input trees.

For instance, using the data set from Whitcher et al. (2025), we can plot the relationship of bootstrap values between molecular (MOL) and total evidence (TE) trees analyzed in TNT.

```{r}
# Load trees
MOL = read.tree("../testdata/051b_MOL_BS_TNT.nwk")
TE = read.tree("../testdata/051d_TE_BS_TNT.nwk")

# Run sharedNodes
df = sharedNodes(tree1=MOL, tree2=TE, spearman = T)

# Plot the relationship of support between trees
ggplot(df, aes(as.numeric(Support_Tree_1), as.numeric(Support_Tree_2))) +
  geom_point(size = 5, show.legend = F, alpha=.5) +
  theme_minimal() + 
  geom_smooth(method = "lm", se = T, color = "red", linewidth = .5) +
  labs(x="\n Bootstrap in the MOL tree",
       y="Bootstrap in the TE tree \n")
```

As expected, there is a significant correlation between bootstrap values of MOL and TE trees (Spearman: rho = 0.89; P < 0.001). 

## 2.3 Logistic regressions

If the user wants to test if support values of one tree predict the occurrence of clades in another tree, the function **retrodictNodes** creates a dataframe containing support values of tree 1 and the occurrence of the clade in tree 2, which can be used for logistic regressions.

```{r}
# Load trees
MOL = read.tree("../testdata/001_MOL_IQTREE.contree")
TE = read.tree("../testdata/001_TE_ASC_IQTREE.contree")

# Run retrodictNodes
df = retrodictNodes(MOL, TE)
df$occurrence_tree2 = as.factor(df$occurrence_tree2)

# Fit the logistic regression
model <- glm(occurrence_tree2 ~ support_tree1, data = df, family = binomial)
summary(model)

# Convert log-odds to odd ratios
exp(coef(model))
```

Using the data set from Janssens et al. (2018), the logistic regression revealed an intercept of 0.009 (i.e. when bootstrap is 0 in the first tree, the odds of presence of the clade in the second tree is 0.009; P < 0.01). Furthermore, for every one-unit increase in bootstrap in the first tree, the odds of presence of the clade in the second tree increase by 1.075 (7.5%). 

## 2.4 Branch length comparisons

In addition to descendants and support values, branch lengths can be compared. Here we used two simple simulated examples.

```{r}
# Read trees
mol = read.tree("../testdata/003_MOL_IQTREE.contree")
te = read.tree("../testdata/003_TE_ASC_IQTREE.contree")

# plot side-by-side
par(mfrow = c(1,2), mar = c(4,4,2,1))  # 1 row, 2 cols
plot(mol, main = "Tree 1", cex = 1, edge.width = 2)
edgelabels(round(mol$edge.length, 3), cex = 0.5)  # show branch length
nodelabels(node = 1:mol$Nnode + length(mol$tip.label), 
            adj = c(1.2, -1), frame = "none", cex = 0.8, col = "red") # show node indices
plot(te, main = "Tree 2", cex = 1, edge.width = 2)
edgelabels(round(te$edge.length, 3), cex = 0.5) # show branch length
nodelabels(node = 1:te$Nnode + length(te$tip.label),
            adj = c(1.2, -1), frame = "none", cex = 0.8, col = "red") # show node indices

# Compare branch lengths
df = RNODE::compareBranchLength(mol, te, composition=F)

# Correlation between branch lengths
summary(lm(data=df, formula=EdgeLength_tree1 ~ EdgeLength_tree2))

# Plot 
ggplot(df, aes(as.numeric(EdgeLength_tree1), as.numeric(EdgeLength_tree2))) +
  geom_point(size = 5, show.legend = F, alpha=.5) +
  theme_minimal() + 
  geom_smooth(method = "lm", se = T, color = "red", linewidth = .5) +
  labs(x="\n Branch lengths in the MOL tree",
       y="Branch lengths in the TE tree \n")
```


## 2.4 Topological distances

# 3. Comparison of DNA sequences

# 4. Manipulation of matrices

*splitOrdFromUnord* splits a Nexus morphological matrix into partitions of ordered and unordered characters

```{r}
# Data input of list of ordered characters
setwd("../../../B2_TEvsMOL/Other/OLD/048_Fossils/iqtree/")

list_ordered=c(1, 6, 7, 8, 10, 12, 13, 14, 17, 19, 23, 26, 31, 35, 41, 44, 45, 48, 51, 54, 55, 68, 71, 72, 92, 94, 96, 102, 105, 108, 109, 128, 129, 130, 131, 132, 135, 142, 144, 152, 153, 193)

RNODE::splitOrdFromUnord(input="048_MORPH_data.nex", output_index = "048_MORPH", list_ordered, invariant = F)
```

# 5. Manipulation of trees

Given a tree A without support values (e.g. strict consensus of optimal trees) and a tree B with support values (e.g. majority consensus from bootstrap pseudo-replicates), *mapSupport()* returns the tree A with support values from shared clades with tree B. 

```{r}
# Read trees
opt = read.tree("../testdata/051a_strictConsensus_MOL_TNT_results.nwk")
BS = read.tree("../testdata/051b_MOL_BS_TNT.nwk")

# Compute topological distances
summaryTopologicalDist(opt, BS)

# Map the BS values from the majority consensus tree to the optimal tree
opt_with_bs = mapSupport(opt, BS)
opt_with_bs[1]

# Plot the optimal tree with BS and the majority consensus tree with BS
uniqueNodes(opt_with_bs[[1]], BS, 
            plotTrees=T, output.tree = "example5.pdf",
            node.numbers=F, 
            tree.fsize=.25, # adjust text size
            tree.cex=1.5, # adjust circle size
            sup.adj1=c(-.2,4), # adjust support from tree a
            sup.adj2=c(1.3,4), # adjust support from tree b
            sup.cex=.25)
```

Another option is mapping branch lengths:

```{r}
# Load trees
MOL = read.tree("../testdata/Whitcher2024_ML_MOL.contree")
TE = read.tree("../testdata/Whitcher2024_ML_TE.contree")

# simulate two random trees with 5 tips (rtree generates branch lengths by default)
set.seed(42)   
tree1 <- rtree(5)
tree2 <- rtree(6)

# show branch lengths
tree1$edge.length
tree2$edge.length
```

# 6. References


